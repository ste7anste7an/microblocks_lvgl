module 'Line Follower' Input
author Ste7an
version 1 3 
choices set_calibration minimum maximum 
choices get_calibration minimum maximum average 
choices commands 'mode raw' 'mode calibrated' 'mode digital' calibrate 'get minimum' 'get maximum' 'get average' 'is calibrated' 'print calibration' 'set minimum' 'set maximum' 'get version' debug 'get position' 'set emitter' 
description 'I2C Line follower on ch32v203'
variables _buf _line_plot _line_buf a _inverted _nr_sensors tmp buf 

  spec ' ' 'init_line' 'init line _ plot _' 'num bool' 8 true
  spec 'r' 'read line' 'read line'
  spec 'r' '_bar_nr' '_bar_nr _' 'auto' '10'
  spec ' ' 'invert' 'invert _' 'bool' true
  spec 'r' 'get position' 'get position'
  spec ' ' 'set emitter level' 'set emitter level _' 'auto' '10'
  spec ' ' 'set calibration' 'set calibration _ values _' 'str.set_calibration auto' 'minimum' '10'
  spec ' ' 'command' 'command _ : value _' 'str.commands auto' 'mode raw' true
  spec 'r' 'get calibration' 'get calibration _' 'str.get_calibration' 'minimum'
  spec 'r' 'is calibrated' 'is calibrated'
  spec ' ' 'save calibration' 'save calibration'
  spec ' ' 'load calibration' 'load calibration'
  spec 'r' 'position_i2c' 'position_i2c'

to '_bar_nr' nr {
  return ('[data:join]' 'bar' nr)
}

to command cmd {
  local 'cmd_id' 0
  if (cmd == 'mode raw') {
    cmd_id = 0
  } (cmd == 'mode calibrated') {
    cmd_id = 1
  } (cmd == 'mode digigtal') {
    cmd_id = 2
  } (cmd == 'calibrate') {
    cmd_id = 3
  } (cmd == 'get minimum') {
    cmd_id = 4
  } (cmd == 'get maximum') {
    cmd_id = 5
  } (cmd == 'get average') {
    cmd_id = 6
  } (cmd == 'is calibrated') {
    cmd_id = 7
  } (cmd == 'print calibration') {
    cmd_id = 8
  } (cmd == 'set minimum') {
    cmd_id = 9
  } (cmd == 'set maximum') {
    cmd_id = 10
  } (cmd == 'get version') {
    cmd_id = 11
  } (cmd == 'debug') {
    cmd_id = 12
  } (cmd == 'get position') {
    cmd_id = 13
  } (cmd == 'set emitter') {
    cmd_id = 14
  }
  local 'buf' ('[data:makeList]' cmd_id)
  '[sensors:i2cWrite]' 51 buf
}

to 'get calibration' minmax {
  local 'buf' (newList _nr_sensors)
  if (minmax == 'minimum') {
    command 'get minimum'
  } (minmax == 'maximum') {
    command 'get maximum'
  } else {
    command 'get average'
  }
  '[sensors:i2cRead]' 51 buf
  return buf
}

to 'get position' {
  local 'adc' 0
  local 'sum' 0
  local 'weightsum' 0
  local 'val' 0
  adc = ('read line')
  for i _nr_sensors {
    val = (at i adc)
    if (val < 50) {
      val = 0
    }
    sum = (sum + val)
    weightsum = (weightsum + ((i + 1) * val))
  }
  if (sum != 0) {
    return ((((weightsum * 255) / sum) - 255) / 7)
  }
  return 0
}

to init_line 'number of sensors' plot {
  _nr_sensors = (v 'number of sensors')
  _line_plot = plot
  _inverted = (booleanConstant false)
  if plot {
    'enable lvgl' true true
    for i _nr_sensors {
      '[tft:LVGLaddobj]' 'bar' ('_bar_nr' i)
      '[tft:LVGLsetsize]' ('_bar_nr' i) 15 100
      '[tft:LVGLsetpos]' ('_bar_nr' i) (i * 20) 20
      '[tft:LVGLsetcolor]' ('_bar_nr' i) (colorSwatch 190 29 9 255) (colorSwatch 255 0 10 255)
      '[tft:LVGLsetattribute]' 'range' ('_bar_nr' i) 0 255
    }
  }
  _line_buf = (newList _nr_sensors)
}

to invert inverted {
  _inverted = inverted
}

to 'is calibrated' {
  local 'buf' (newList 1)
  command 'is calibrated'
  '[sensors:i2cRead]' 51 buf
  return ((at 1 buf) == 1)
}

to 'load calibration' {
  local 'vals' 0
  '[file:open]' 'cal_val.bin'
  tmp = ('[data:convertType]' ('[file:readBytes]' 8 'cal_val.bin') 'list')
  if ((size tmp) > 0) {
    'set calibration' 'minimum' tmp
    tmp = ('[data:convertType]' ('[file:readBytes]' 8 'cal_val.bin') 'list')
    'set calibration' 'maximum' tmp
    '[file:close]' 'cal_val.bin'
  } else {
    sayIt 'no callibration file found'
  }
}

to position_i2c {
  command 'get position'
  buf = (newList 3)
  '[sensors:i2cRead]' 51 buf
  return buf
}

to 'read line' {
  '[sensors:i2cRead]' 51 _line_buf
  if _inverted {
    for i _nr_sensors {
      atPut i _line_buf (255 - (at i _line_buf))
    }
  }
  if _line_plot {
    for i _nr_sensors {
      '[tft:LVGLsetval]' ('_bar_nr' i) (at i _line_buf)
    }
  }
  return _line_buf
}

to 'save calibration' {
  local 'vals' 0
  if ('is calibrated') {
    vals = ('get calibration' 'minimum')
    if ((size vals) > 0) {
      '[file:delete]' 'cal_val.bin'
      '[file:open]' 'cal_val.bin'
      '[file:appendBytes]' ('[data:convertType]' vals 'byte array') 'cal_val.bin'
      vals = ('get calibration' 'maximum')
      '[file:appendBytes]' ('[data:convertType]' vals 'byte array') 'cal_val.bin'
      '[file:close]' 'cal_val.bin'
    } else {
      sayIt 'noy yet calibrated'
    }
  } else {
    sayIt 'noy yet calibrated'
  }
}

to 'set calibration' minmax values {
  if ((size values) != _nr_sensors) {
    sayIt 'length of value array is not equal to number of sensors'
  } else {
    if (minmax == 'minimum') {
      '[sensors:i2cWrite]' 51 ('[data:join]' ('[data:makeList]' 9) values)
    } else {
      '[sensors:i2cWrite]' 51 ('[data:join]' ('[data:makeList]' 10) values)
    }
  }
}

to 'set emitter level' level {
  '[sensors:i2cWrite]' 51 ('[data:makeList]' 14 level)
}

